{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/App.svelte",
    "../src/InGameMenu.svelte"
  ],
  "sourcesContent": [
    "<script>\nimport ProgressWheel from './ProgressWheel.svelte';\nimport { terra, researchProgress, nextTurn, turns, numWorkable } from './stores.js';\nimport { Pawn } from './pawn.js';\nimport InGameMenu from './InGameMenu.svelte';\n\n/** Grid is the visible world/board\n  * Functions for creating and zooming in and out \n  */\nlet grid = {\n    tiles : [],\n    numColumns : 4,\n}\n\nlet startX = 0;\nlet startY = 0;\n$: startX = (0 <= startX) ? startX : 0;\n$: startY = (0 <= startY) ? startY : 0;\n$: recreate(startX, startY);\n// TODO: the above should check an upper bound for startX and startY as well\n\nfunction recreate(startX = 0, startY = 0) {\n    let temp = [];\n    for (let y = startY; y < grid.numColumns + startY; y++) {\n        for (let x = startX; x < grid.numColumns + startX; x++) {\n            temp.push(terra[x][y]);\n        }\n    }\n    grid.tiles = temp;\n}\n\nrecreate();\n\n// refresh the grid every turn end\n// solves bugs like tile transformations not appearing on time\nturns.subscribe(() =>\n    grid.tiles = grid.tiles);\n\nfunction incColumns() { \n    grid.numColumns += 1;\n    recreate();\n}\n\nfunction decColumns() {\n    grid.numColumns -= 1;\n    recreate();\n}\n\n\nlet fromIndex;\nlet fromCoordinates;\nlet count = 0;\n\nfunction allowDrop(ev) {\n    ev.preventDefault();\n}\n\nfunction indexAndCoords(ev) {\n    const arr = ev.target.id.split('/');\n    const index = arr[0];\n    const coordinates = arr[1].split(','); \n    return [ index, coordinates ];\n}\n\nfunction drag(ev) { \n    [fromIndex, fromCoordinates] = indexAndCoords(ev);\n    ev.dataTransfer.setData(\"text\", ev.target.id);\n}\n\nfunction swap(key, targetIndex, fromIndex) {\n    [grid.tiles[targetIndex][key], grid.tiles[fromIndex][key]] = [grid.tiles[fromIndex][key], grid.tiles[targetIndex][key]]\n}\n\nfunction distance(fromCoordinates, targetCoordinates) {\n    const [x1, y1] = fromCoordinates;\n    const [x2, y2] = targetCoordinates;\n    const horizontal = Math.abs(x2 - x1);\n    const vertical = Math.abs(y2 - y1);\n    // handle diagonal case\n    if (horizontal == vertical == 1) return 1;\n    else return horizontal + vertical;\n}\n\nlet pawnsTile;\nfunction drop(ev) {\n    ev.preventDefault();\n    const [targetIndex, targetCoordinates] = indexAndCoords(ev);\n    const pawn = grid.tiles[fromIndex].pawn;\n    const dist = distance(fromCoordinates, targetCoordinates);\n    if (pawn.moves - dist >= 0) {\n        swap('img', targetIndex, fromIndex);\n        swap('pawn', targetIndex, fromIndex);\n        pawn.moves -= dist;\n        pawnsTile = grid.tiles[targetIndex];\n    }\n    //let data = ev.dataTransfer.getData(\"text\");\n    //ev.target.appendChild(document.getElementById(data));\n}\n\nlet options = []; // can be for pawns or whatever else\n\nfunction pawnClicked(ev) {\n    console.log('pawn clicked');\n    const [index, _] = indexAndCoords(ev);\n    const tile = grid.tiles[index];\n    pawnsTile = tile;\n    const pawn = tile.pawn;\n    options = pawn.options;\n}\n\nfunction optionSelectedHandler() {\n    \n}\n</script>\n\n<style>\n    .grid-container {\n        display: grid;\n        width: 16em;\n        height: 16em;\n    }\n\n    .tile {\n        position: relative;\n        border: solid 1px black;\n        width: 4em; /* TODO: magic numbers! */\n        height: 4em;\n        background-color: green;\n    }\n\n    .worked {\n        border: solid 1px yellow;\n    }\n\n    .tile img {\n        position: absolute;\n        top: 0px;\n        right: 0px;\n        bottom: 0px;\n        left: 0px;\n        height: 100%;\n        width: 100%;\n        max-height: 100%;\n        max-width: 100%;\n    }\n\n    #button-panel {\n        border: solid 1px black;\n    }\n</style>\n\n<link rel=\"stylesheet\" type=\"text/css\" href=\"main.css\" />\n\n<div class='grid-container' style='grid-template-columns: repeat({grid.numColumns}, auto)'>\n    {#each grid.tiles as tile, index}\n        <div class=\"tile {tile.isWorked ? 'worked' : ''}\" on:drop='{drop}' on:dragover='{allowDrop}'>\n                <img id='{index}/{tile.coordinates}' src={tile.img} \n                    on:click={pawnClicked}\n                    alt='{tile.coordinates}' \n                    draggable='true' on:dragstart='{drag}'>\n            {#if (tile.terrain.svg) }\n                <object title='{tile.terrain.svg}' type=\"image/svg+xml\" data=\"assets/{tile.terrain.svg}.svg\"/>\n            {/if}\n        </div>\n    {/each}\n</div>\n<button on:click={incColumns}>+</button>\n<button on:click={decColumns}>-</button>\n<ProgressWheel/>\n<button on:click={nextTurn}>next turn</button>\n<div id='button-panel'>\n    {#each options as  { text, handler} }\n        <button on:click='{() => { handler(pawnsTile); }}'>{text}</button>\n    {/each}\n</div>\n<button on:click='{ () => startX-- }'>left</button>\n<button on:click='{ () => startX++ }'>right</button>\n<InGameMenu on:optionSelected={optionSelectedHandler} />\n",
    "<script>\n// Modal box on pop-up\n\nimport { createEventDispatcher } from 'svelte';\n\nconst dispatch = createEventDispatcher();\nlet isPoppedUp = false;\nlet modal;\n\nfunction chooseWorkedTiles() {\n    isPoppedUp = false;\n    dispatch('optionSelected', { text : 'chooseWorkedTiles' });\n}\n\nfunction handler(e) {\n    e = e || window.event;\n    switch(e.key) {\n        case 'p':\n        case 'Control':\n            isPoppedUp = true;\n            break;\n        case 'Escape':\n            isPoppedUp = false;\n            break;\n    }\n    \n    if (isPoppedUp) {\n        switch(e.key) {\n            case 'w':\n                chooseWorkedTiles();\n                break;\n        }\n    }\n}\n\ndocument.addEventListener('keypress', handler);\ndocument.addEventListener('keydown', handler);\n\n// When the user clicks anywhere outside of the modal, close it\nwindow.addEventListener('click', function(event) {\n    if (event.target == modal) {\n        isPoppedUp = false;\n    }\n});\n\n</script>\n<style>\n\n/* The Modal (background) */\n.modal {\n  display: none; /* Hidden by default */\n  position: fixed; /* Stay in place */\n  z-index: 1; /* Sit on top */\n  padding-top: 100px; /* Location of the box */\n  left: 0;\n  top: 0;\n  width: 100%; /* Full width */\n  height: 100%; /* Full height */\n  overflow: auto; /* Enable scroll if needed */\n  background-color: rgb(0,0,0); /* Fallback color */\n  background-color: rgba(0,0,0,0.4); /* Black w/ opacity */\n}\n\n/* Modal Content */\n.modal-content {\n  background-color: #fefefe;\n  margin: auto;\n  padding: 20px;\n  border: 1px solid #888;\n  width: 80%;\n}\n\n.display-block {\n    display: block;\n}\n\n/* The Close Button */\n.close {\n  color: #aaaaaa;\n  float: right;\n  font-size: 28px;\n  font-weight: bold;\n}\n\n.close:hover,\n.close:focus {\n  color: #000;\n  text-decoration: none;\n  cursor: pointer;\n}\n\n.option-container p {\n    border: 1px solid black;\n}\n\n</style>\n\n<!-- The Modal -->\n<div bind:this={modal} \n    class=\"modal\" class:display-block={isPoppedUp} >\n  <!-- Modal content -->\n  <div class=\"modal-content option-container\">\n    <span class=\"close\"\n        on:click='{() => isPoppedUp = false}'>&times;</span>\n    <p on:click={chooseWorkedTiles}>Change what tiles are worked</p>\n  </div>\n</div>\n"
  ],
  "names": [],
  "mappings": "AAoHI,eAAe,cAAC,CAAC,AACb,OAAO,CAAE,IAAI,CACb,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,KAAK,cAAC,CAAC,AACH,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,KAAK,CAAC,GAAG,CAAC,KAAK,CACvB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,CACX,gBAAgB,CAAE,KAAK,AAC3B,CAAC,AAED,OAAO,cAAC,CAAC,AACL,MAAM,CAAE,KAAK,CAAC,GAAG,CAAC,MAAM,AAC5B,CAAC,AAED,mBAAK,CAAC,GAAG,cAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,GAAG,CACR,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,CACX,IAAI,CAAE,GAAG,CACT,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,IAAI,CAChB,SAAS,CAAE,IAAI,AACnB,CAAC,AAED,aAAa,cAAC,CAAC,AACX,MAAM,CAAE,KAAK,CAAC,GAAG,CAAC,KAAK,AAC3B,CAAC;ACnGL,MAAM,cAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,QAAQ,CAAE,KAAK,CACf,OAAO,CAAE,CAAC,CACV,WAAW,CAAE,KAAK,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,IAAI,CACd,gBAAgB,CAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAC5B,gBAAgB,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AACnC,CAAC,AAGD,cAAc,cAAC,CAAC,AACd,gBAAgB,CAAE,OAAO,CACzB,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,KAAK,CAAE,GAAG,AACZ,CAAC,AAED,cAAc,cAAC,CAAC,AACZ,OAAO,CAAE,KAAK,AAClB,CAAC,AAGD,MAAM,cAAC,CAAC,AACN,KAAK,CAAE,OAAO,CACd,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,IAAI,AACnB,CAAC,AAED,oBAAM,MAAM,CACZ,oBAAM,MAAM,AAAC,CAAC,AACZ,KAAK,CAAE,IAAI,CACX,eAAe,CAAE,IAAI,CACrB,MAAM,CAAE,OAAO,AACjB,CAAC,AAED,+BAAiB,CAAC,CAAC,cAAC,CAAC,AACjB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,AAC3B,CAAC"
}